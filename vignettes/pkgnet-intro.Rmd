---
title: "Exploring The Structure and Dependencies of An R Package"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setupVignette, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.align = 'center'
)
```


<!--  STYLE SET UP FOR TWO COLUMN SECTIONS  -->
<style>
.column-left{
  float: left;
  width: 50%;
  text-align: left;
}
.column-right{
  float: right;
  width: 50%;
  text-align: left;
}
</style>


<!--  CODE BELOW HERE WILL RENDER  -->

`pkgnet` is an R library designed for the analysis of R libraries! The goal of the package is to build a graph representation of a package and its dependencies to inform a variety of activities, including:

- prioritizing functions to unit test based on their centrality
- examining the recursive dependencies you are taking on by using a given package
- exploring the structure of a new package provided by a coworker or downloaded from the internet

Below is a brief tour of `pkgnet` and its features. 

***
# Running pkgnet

`pkgnet` can analyze any R package locally installed.  Run `installed.packages()` to see the full list of packages installed on your system.  For this example, let's say we are analyzing a custom built package, `baseballstats`.

```{r makeDemoPackage, include=FALSE}
devtools::install_local(system.file('baseballstats',package="pkgnet"),force=TRUE)
```

To analyze `baseballstats`, run the following two lines of code: 

```{r pkgnetRunFirst, message=FALSE, warning=FALSE, results='hide'}
library(pkgnet)
report1 <- CreatePackageReport(pkg_name = "baseballstats")
```

That's it! You have generated a lot of valuable information with that one call for an installed package.  

However, if the full source repository for the package is available on your system, you can supplement this report with other information such as code coverage from [covr](https://cran.r-project.org/web/packages/covr/index.html).  To do so, specify the path to the repository in `CreatePackageReport`.  


```{r pkgnetRunFAKE, eval=FALSE}
library(pkgnet)
report2 <- CreatePackageReport(
  pkg_name = "baseballstats"
  , pkg_path = <path to the repo>
)
```

```{r pkgnetRunSecond, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(pkgnet)
report2 <- CreatePackageReport(
  pkg_name = "baseballstats"
  , pkg_path = system.file('baseballstats',package="pkgnet")
)
```

***
# Dependencies As a Graph
Most R packages depend upon other R packages that then depend upon other R packages and so on.  Most R packages also consist of a collection of functions with similar cascading dependencies. To capture and quantify the complexity of these dependency networks, `pkgnet` represents both package depedencies and function dependencies as directed graphs. 

## One Dependency
Functions or Dependencies are represented as nodes, and their dependent relationships are represented as edges (a.k.a. arcs or arrows).  The direction of the edge points towards the node that is dependant on the other node.  

In the example below, **C** is dependant upon **A**. 

```{r whatIsDep, echo=FALSE, message=FALSE, results='markup', fig.height=1}
nodes <- data.frame(
  id = 1:2
  , label = c("A","C")
  , level = 1:1
)
edges <- data.frame(
  from = 1
  , to = 2
)

g <- visNetwork::visNetwork(nodes = nodes
                       , edges = edges
                       , width = "100%"
                       )
g <- visNetwork::visNodes(graph = g
                          , shape = "circle"
                          , font = list(size = 50
                                        , bold = TRUE
                                        , align = 'center'
                                        )
                       )
g <- visNetwork::visEdges(graph = g
                          , arrows = "to"
                       )
g <- visNetwork::visHierarchicalLayout(graph = g
                      , direction = "DU"
                      )
g <- visNetwork::visInteraction(graph = g
                                , dragNodes = TRUE
                                , dragView = TRUE
                                , zoomView = FALSE)
g
```


## A Network of Dependencies
sdasf dsaf sd fasf asd fsda 

```{r whatIsDepGraph, echo=FALSE, message=FALSE, results='markup'}
nodes <- data.frame(
  id = 1:4
  , label = LETTERS[1:4]
  , x = c(1,3,2,4)
  , y = c(1,1,2,3)
  , level = c(1,1,2,3)
  )

edges <- data.frame(
  from = c(1,2,3,2)
  , to = c(3,3,4,4)
  )

g <- visNetwork::visNetwork(nodes = nodes
                       , edges = edges
                       , width = "100%"
                       )
g <- visNetwork::visNodes(graph = g
                          , shape = "circle"
                          , font = list(size = 25
                                        , bold = TRUE
                                        , align = 'center'
                                        )
                       )
g <- visNetwork::visEdges(graph = g
                          , arrows = "to"
                       )
g <- visNetwork::visHierarchicalLayout(graph = g
                      , direction = "DU"
                      )
g <- visNetwork::visInteraction(graph = g
                                , dragNodes = TRUE
                                , dragView = TRUE
                                , zoomView = FALSE)
g
```


***
# Examining The Results

An HTML report has been created with the pertinent information and a list object is available with the same information and more.  

## The Report

An HTML report has been created, and its location is specified in the messages in the terminal.  

This report has three sections: 

1. **Package Summary** -- general information about the package and package level statistics   
2. **Dependency Network** -- information regarding the packages upon which the current package under analysis relies upon    
3. **Function Network** -- information regarding the functions within the current package under analysis and their interdependencies     

Each section has helpful tables and visuals.  

As a sample, here's how the **Function Network Visualization** looks for `pkgnet`: 

<!--  SIDE BY SIDE START  -->
<!--  Take care to ensure equal lengths  -->
<div class="column-left">
#### Default
```{r demoVis1, echo=FALSE, fig.width=3, fig.height=3}
report1$PackageFunctionReporter$graph_viz
```
Functional dependencies are visible.  For example, we can see that both `batting_avg` and `slugging_avg` functions depend upon the `at_bats` function.  

We also see that nothing depends on the `on_base_pct` function.  This might be valuable information to an R package developer. 
</div>

<div class="column-right">
#### With Coverage Information 
```{r demoVis2, echo=FALSE, , fig.width=3, fig.height=3}
report2$PackageFunctionReporter$graph_viz
```
Same as the default visualization except we can see coverage information as well (Red = 0%, Green = 100%). 

It appears the function that most other functions depend upon, `at_bats`, is well covered.  However, no other functions are covered by unit tests.
</div>

<!--  SIDE BY SIDE END -->

<br><br>

#### Check out the full HTML report for more results  

## The List Object

The `CreatePackageReport()` function returns a list with three items: 

1. PackageSummaryReporter  
2. PackageDependencyReporter  
3. PackageFunctionReporter  

Each items contains information visible in the report *and more*.  We can use this information for a more detailed analysis of the results and/or more easily incorporate `pkgnet` results into other R processes.

Here are a few notable items available within the list object.

### Node Information
Both the `PackageDependencyReporter` and the `PackageFunctionReporter` contain metrics about their package dependencies or functions (a.k.a network nodes) in a `nodes` table.  

```{r nodes}
dim(report2$PackageFunctionReporter$nodes)
names(report2$PackageFunctionReporter$nodes)
```

### Network Measures 
Both the `PackageDependencyReporter` and the `PackageFunctionReporter` contain measure based on their network structure in a `network_measures` list. 

```{r networkMeasures}
report2$PackageFunctionReporter$network_measures
```

### Network Object
Both the `PackageDependencyReporter` and the `PackageFunctionReporter` are available as [igraph](http://igraph.org/r/) objects named `pkg_graph`

```{r networkObj}
report2$PackageFunctionReporter$pkg_graph
```

***
# A Deeper Look
With the reports and objects produced by `pkgnet` by default, there is plenty to inform us on the inner workings of an R package.  However, we may want to know MORE! Since the [igraph](http://igraph.org/r/) objects are available, we can leverage those graphs for further analysis.  

In this section, let's examine a larger R package, such as [lubridate](http://lubridate.tidyverse.org/).

If you would like to follow along with the examples in this section^[Examples from version 1.7.3 of Lubridate], run these commands in your terminal to download and install `lubridate`.  
```{r bashText, engine='bash', eval=FALSE}
# Create a temporary workspace
mkdir -p ~/pkgnet_example && cd ~/pkgnet_example

# Grab the lubridate source code
git clone https://github.com/tidyverse/lubridate

# Install it
cd lubridate
Rscript -e "devtools::install()"
```

## Coverage of Most Referenced Functions
Let's visualize the relationship between function centrality and code coverage.

<!--  Faked Since lubridate not guaranteed to be installed at time of report creation -->
```{r fakeDetail1, eval=FALSE}
# Run pkgnet
library(pkgnet)
report2 <- CreatePackageReport(pkg_name = "lubridate"
                                         , pkg_path = "~/pkgnet_example/lubridate")

# Extract Nodes Table
funcNodes <- report2$PackageFunctionReporter$nodes

# List Coverage For Most Referenced Functions
mostRef <- funcNodes[order(numDescendants, decreasing = TRUE)][1:10]
mostRef[,list(node, numDescendants, coverageRatio, totalLines)]

```

|node                   | numDescendants| coverageRatio| totalLines|
|:----------------------|--------------:|-------------:|----------:|
|dmicroseconds          |             39|     0.0000000|          1|
|days_in_months_so_far  |             22|     0.0000000|         10|
|check_period           |             15|     0.0000000|         12|
|as.difftime            |             13|            NA|         NA|
|fast_strptime          |             13|     0.8571429|          7|
|comp_posix_date        |             12|     0.7692308|         13|
|date_to_posix          |             12|     1.0000000|          2|
|ceiling_date           |             10|     0.9666667|         30|
|add_number_to_duration |              8|     1.0000000|          1|
|check_interval         |              8|     0.0000000|         11|

Inspecting results such as these can help an R package developer decide which function to cover with unit tests next.  In this case, the most referenced function, `dmicroseconds`, appears to be a simple one line function that may not be necessary to cover in unit testing.  However, the second most referenced function, `days_in_months_so_far`, might benefit from some unit test coverage.

## Discovering Similar Functions
Looking at that same large package, let's say we wanted to explore options for consolidating functions.  In that case, we could use the `igraph` object to highlight functions with the same dependencies via Jaccard similarity. 

```{r fakeDetail2, eval=FALSE}
# Get igraph object
funcGraph <- report2$PackageFunctionReporter$pkg_graph
funcNames <- igraph::vertex_attr(funcGraph, name = "name")

# Jaccard Similarity
sim <- igraph::similarity(graph = funcGraph
                          , mode = "in"
                          , method = "jaccard")
diag(sim) <- 0
sim[sim < 1] <- 0

simGraph <- igraph::graph_from_adjacency_matrix(adjmatrix = sim, mode = "undirected")

# Find groups with same dependencies (similarity == 1)
sameDeps <- igraph::max_cliques(graph = simGraph
                                , min = 2
                                )

# Write results
for (i in seq_along(sameDeps)) {
         cat(paste0("Group ", i, ": "))
         cat(paste(funcNames[as.numeric(sameDeps[[i]])], collapse = ", "))
         cat("\n")
}
```
  
```{r resultFromFake, echo=FALSE, results='markup'}
cat("Group 1: stamp_time, stamp_date
Group 2: ms, hm
Group 3: new_interval, %--%, int_diff
Group 4: floor_date, quarter, semester
Group 5: picoseconds, microseconds, nanoseconds, milliseconds
Group 6: weeks, days, years, seconds_to_period, seconds, new_period, minutes, hours
Group 7: yq, dmy, ymd_hms, ymd_hm, ymd_h, ymd, ydm_hms, ydm_hm, ydm_h, ydm, pretty_dates, parse_date_time2, parse_date_time, myd, mdy_hms, mdy_hm, mdy_h, mdy, local_time, fast_strptime, dym, dmy_hms, dmy_hm, dmy_h
"
)
```





```{r removeDemoPackage, include=FALSE}
devtools::uninstall(system.file('baseballstats',package="pkgnet"))
```

